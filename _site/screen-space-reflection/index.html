<!DOCTYPE html> <!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]--> <!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8"><![endif]--> <!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9"><![endif]--> <!--[if gt IE 8]><!--> <html class="no-js"><!--<![endif]--> <head> <meta charset="UTF-8"> <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"> <meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"> <title>Screen Space Reflection &#8211; Silver Alex</title> <meta name="description" content="That which does not kill us makes us stronger."> <meta name="keywords" content="Render, Screen Space, Graphics, Global Illumination"> <!-- Twitter Cards --> <meta name="twitter:card" content="summary_large_image"> <meta name="twitter:image" content="https://github.com/OneSilverBullet/SilverGamer.GitHub.io/blob/gh-pages/_img/blogHead/SSR.jpg"> <meta name="twitter:title" content="Screen Space Reflection"> <meta name="twitter:description" content="Fake Global Illumination: Achieve effect comparable to global illumination with minimal cost."> <!-- Open Graph --> <meta property="og:locale" content="en_US"> <meta property="og:type" content="article"> <meta property="og:title" content="Screen Space Reflection"> <meta property="og:description" content="Fake Global Illumination: Achieve effect comparable to global illumination with minimal cost."> <meta property="og:url" content="https://onesilverbullet.github.io/silvergamer.github.io/screen-space-reflection/"> <meta property="og:site_name" content="Silver Alex"> <meta property="og:image" content="https://onesilverbullet.github.io/silvergamer.github.io/assets/img/logo.png"> <link rel="canonical" href="https://onesilverbullet.github.io/silvergamer.github.io/screen-space-reflection/"> <link href="https://onesilverbullet.github.io/silvergamer.github.io/feed.xml" type="application/atom+xml" rel="alternate" title="Silver Alex Feed"> <!-- Handheld --> <meta name="HandheldFriendly" content="True"> <meta name="MobileOptimized" content="320"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- CSS --> <link rel="stylesheet" href="https://onesilverbullet.github.io/silvergamer.github.io/assets/css/main.css"> <!-- JS --> <script src="https://onesilverbullet.github.io/silvergamer.github.io/assets/js/modernizr-3.3.1.custom.min.js"></script> <!-- Favicons --> <link rel="apple-touch-icon" href="https://onesilverbullet.github.io/silvergamer.github.io/assets/img/favicons/apple-icon-precomposed.png"> <link rel="apple-touch-icon" sizes="72x72" href="https://onesilverbullet.github.io/silvergamer.github.io/assets/img/favicons/apple-icon-72x72.png"> <link rel="apple-touch-icon" sizes="114x114" href="https://onesilverbullet.github.io/silvergamer.github.io/assets/img/favicons/apple-icon-114x114.png"> <link rel="apple-touch-icon" sizes="144x144" href="https://onesilverbullet.github.io/silvergamer.github.io/assets/img/favicons/apple-icon-144x144.png"> <link rel="shortcut icon" type="image/png" href="https://onesilverbullet.github.io/silvergamer.github.io/favicon.png" /> <link rel="shortcut icon" href="https://onesilverbullet.github.io/silvergamer.github.io/favicon.ico" /> <!-- Background Image --> <style type="text/css">body {background-image:url(https://onesilverbullet.github.io/silvergamer.github.io/assets/img/placeholder-big.jpg); background-repeat: no-repeat; background-size: cover; }</style> <!-- Post Feature Image --> <style type="text/css">.feature {background-image:url(https://github.com/OneSilverBullet/SilverGamer.GitHub.io/blob/gh-pages/_img/blogHead/SSR.jpg);}</style> </head> <body> <nav id="dl-menu" class="dl-menuwrapper" role="navigation"> <button class="dl-trigger">Open Menu</button> <ul class="dl-menu"> <li><a href="https://onesilverbullet.github.io/silvergamer.github.io/">Home</a></li> <li> <a href="#">About</a> <ul class="dl-submenu"> <li> <img src="https://onesilverbullet.github.io/silvergamer.github.io/assets/img/logo.png" alt="Silver Alex photo" class="author-photo"> <h4>Silver Alex</h4> <p>That which does not kill us makes us stronger.</p> </li> <li><a href="https://onesilverbullet.github.io/silvergamer.github.io/about/"><span class="btn btn-inverse">Learn More</span></a></li> <li> <a href="http://github.com/OneSilverBullet?tab=repositories" target="_blank" rel="noopener noreferrer"><i class="fa fa-fw fa-github"></i> Github</a> </li> </ul><!-- /.dl-submenu --> </li> <li> <a href="#">Posts</a> <ul class="dl-submenu"> <li><a href="https://onesilverbullet.github.io/silvergamer.github.io/posts/">All Posts</a></li> <li><a href="https://onesilverbullet.github.io/silvergamer.github.io/tags/">All Tags</a></li> </ul> </li> <li><a href="https://onesilverbullet.github.io/silvergamer.github.io/projects/" >Projects</a></li> <li><a href="https://onesilverbullet.github.io/silvergamer.github.io/blog/" >Blog</a></li> </ul><!-- /.dl-menu --> </nav><!-- /.dl-menuwrapper --> <!-- Header --> <header class="header" role="banner"> <div class="wrapper animated fadeIn"> <div class="content"> <div class="post-title feature "> <h1>Screen Space Reflection</h1> <h4>11 Nov 2021</h4> <p class="reading-time"> <i class="fa fa-clock-o"></i> Reading time ~9 minutes </p><!-- /.entry-reading-time --> <a class="btn zoombtn" href="https://onesilverbullet.github.io/silvergamer.github.io/blog/"> <i class="fa fa-chevron-left"></i> </a> </div> <h2 id="overview">Overview</h2> <ul> <li>SSR works by reflectingb the screen image onto itself using only iteself.</li> <li>SSR reflect a ray from some point on your screen to some other point on your screen.</li> </ul> <h3 id="ray-marching">Ray Marching</h3> <ul> <li>Ray Marching is the process of iteratively extending or contracting the length or magnitude of some vector in order to probe or sample some space for information.</li> </ul> <h3 id="screen-space-reflection">Screen Space Reflection</h3> <ul> <li>SSR is the process of tracing the light ray’s path in reverse. It tries to find the reflected point the light ray bounced off of and hit the current fragment.</li> </ul> <h3 id="algorithm-thinking">Algorithm Thinking</h3> <ul> <li>With each iteration, the algorithm samples the scene’s positions or depths, along the reflection ray, asking each time if the ray intersected with the scene’s geometry.</li> <li>If there is an intersection, that position is a potential condidate for being reflected by the current fragment.</li> </ul> <h2 id="implementation">Implementation</h2> <h3 id="vertex-normal">Vertex Normal</h3> <ul> <li>Target: Reflection follows the ripples in the water versus the more mirror like reflection shown earlier.</li> <li>Solution: Normal Mapped.</li> </ul> <h3 id="position-transformation">Position Transformation</h3> <ul> <li>SSR goes back and forth between the <strong>screen space</strong> and <strong>view space</strong>.</li> <li>From view space to clip space: projection matrix.</li> <li>From clip space to uv space.</li> <li>In UV space, you can sample a vertex/fragment position from the scene which will be the closest position in the scene to your sample.</li> </ul> <h3 id="reflected-uv-coordinate">Reflected UV Coordinate</h3> <ul> <li>Target: Computing a reflected UV coordinate for each screen fragment.</li> <li>These calculated uv coordinates can be saved to a framebuffer, and used later when the scene has been rendered.</li> </ul> <figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">cameraProjection</span><span class="p">;</span>
<span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">viewSpacePositionTex</span><span class="p">;</span>
<span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">normalTex</span><span class="p">;</span></code></pre></figure> <p>The Data needed for SSR.</p> <figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">float</span> <span class="n">maxDistance</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">resolution</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">steps</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">thickness</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span></code></pre></figure> <p>Some Defination:</p> <p><strong>First Pass</strong>: The first pass is to find a point along the ray’s direction where the ray enters or goes behind some geometry in the scene.</p> <p><strong>Second Pass</strong>: The second Pass is to find the exact point along the reflection ray’s direction where the ray immediately hits or intersects with some geometry in the scene.</p> <ul> <li>maxDistance: How far a fragment can reflect. In other words, it controls the length of the reflection ray.</li> <li>resolution: How many fragments are skipped while traveling or marching the reflection ray during the first pass.</li> <li>steps: how many iterations occur during the second pass.</li> <li>thickness: It controls the cutoff between what counts as a possible reflection and what does not.</li> </ul> <figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">vec2</span> <span class="n">texSize</span> <span class="o">=</span> <span class="n">textureSize</span><span class="p">(</span><span class="n">viewSpacePositionTex</span><span class="p">,</span> <span class="mi">0</span><span class="p">).</span><span class="n">xy</span><span class="p">;</span>
<span class="n">vec2</span> <span class="n">texCoord</span> <span class="o">=</span> <span class="n">gl_FragCoord</span><span class="p">.</span><span class="n">xy</span> <span class="o">/</span> <span class="n">texSize</span><span class="p">;</span>
<span class="n">vec4</span> <span class="n">positionFrom</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">viewSpacePositionTex</span><span class="p">,</span> <span class="n">texCoord</span><span class="p">);</span>
<span class="n">vec3</span> <span class="n">unitPositionFrom</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">positionFrom</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
<span class="n">vec3</span> <span class="n">normal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">normalTexture</span><span class="p">,</span> <span class="n">texCoord</span><span class="p">).</span><span class="n">xyz</span><span class="p">);</span>
<span class="n">vec3</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">reflect</span><span class="p">(</span><span class="n">unitPositionFrom</span><span class="p">,</span> <span class="n">normal</span><span class="p">));</span></code></pre></figure> <ul> <li>positionFrom: the vector from the camera to the current fragment.</li> <li>normal: the vector pointing in the direction of the interpolated vertex normal for the current fragment.</li> <li>pivot: the reflection ray or vector pointing in the reflected direction of the positionFrom vector.</li> </ul> <figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">vec4</span> <span class="n">startViewPoint</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">positionFrom</span><span class="p">.</span><span class="n">xyz</span> <span class="o">+</span> <span class="p">(</span><span class="n">pivot</span> <span class="o">*</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">vec4</span> <span class="n">endViewPoint</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">positionFrom</span><span class="p">.</span><span class="n">xyz</span> <span class="o">+</span> <span class="p">(</span><span class="n">pivot</span> <span class="o">*</span> <span class="n">maxDistance</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span></code></pre></figure> <p>Get the start and end point of reflection ray in view space.</p> <figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">vec4</span> <span class="n">startFrag</span> <span class="o">=</span> <span class="n">startViewPosition</span><span class="p">;</span>
<span class="n">startFrag</span> <span class="o">=</span> <span class="n">cameraProjection</span> <span class="o">*</span> <span class="n">startFrag</span><span class="p">;</span>
<span class="n">startFrag</span><span class="p">.</span><span class="n">xyz</span> <span class="o">/=</span> <span class="n">startFrag</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
<span class="n">startFrag</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">startFrag</span><span class="p">.</span><span class="n">xy</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">;</span>
<span class="n">startFrag</span><span class="p">.</span><span class="n">xy</span> <span class="o">*=</span> <span class="n">texSize</span><span class="p">;</span>

<span class="n">vec4</span> <span class="n">endFrag</span> <span class="o">=</span> <span class="n">endViewPosition</span><span class="p">;</span>
<span class="n">endFrag</span> <span class="o">=</span> <span class="n">cameraProjection</span> <span class="o">*</span> <span class="n">endFrag</span><span class="p">;</span>
<span class="n">endFrag</span><span class="p">.</span><span class="n">xyz</span> <span class="o">/=</span> <span class="n">endFrag</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
<span class="n">endFrag</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">endFrag</span><span class="p">.</span><span class="n">xy</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">;</span>
<span class="n">endFrag</span><span class="p">.</span><span class="n">xy</span> <span class="o">*=</span> <span class="n">texSize</span><span class="p">;</span></code></pre></figure> <p>Project and transform the start view position and end view position to the screen space. We will travel along this line using it to sample the fragment positions stored in the position fragment textures.</p> <p>Screen Space Reflection uses marching in screen space, which is more efficiently than marching in view space.</p> <figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">vec2</span> <span class="n">frag</span> <span class="o">=</span> <span class="n">startFrag</span><span class="p">.</span><span class="n">xy</span><span class="p">;</span>
<span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">frag</span> <span class="o">/</span> <span class="n">texSize</span><span class="p">;</span></code></pre></figure> <p>Converting the fragment position to UV coordinate.</p> <figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">float</span> <span class="n">deltaX</span> <span class="o">=</span> <span class="n">endFrag</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">startFrag</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">deltaY</span> <span class="o">=</span> <span class="n">endFrag</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">startFrag</span><span class="p">.</span><span class="n">y</span><span class="p">;</span></code></pre></figure> <p>Calculate the delta or difference between the X and Y coordinates of the end and start fragments.</p> <figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">float</span> <span class="n">useX</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">deltaX</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">abs</span><span class="p">(</span><span class="n">deltaY</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">mix</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">deltaY</span><span class="p">),</span> <span class="n">abs</span><span class="p">(</span><span class="n">deltaX</span><span class="p">),</span> <span class="n">useX</span><span class="p">)</span> <span class="o">*</span> <span class="n">clamp</span><span class="p">(</span><span class="n">resolution</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span></code></pre></figure> <p>To handle all of various different ways, we should keep track of the larger difference. The larger difference help us to determine how much to travel in X and Y direction each iteration.</p> <figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">vec2</span> <span class="n">increment</span> <span class="o">=</span> <span class="n">vec2</span><span class="p">(</span><span class="n">deltaX</span><span class="p">,</span> <span class="n">deltaY</span><span class="p">)</span> <span class="o">/</span> <span class="n">max</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">);</span></code></pre></figure> <p>The increment is the step we move every iteration.</p> <figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">float</span> <span class="n">search0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">search1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">current_position_x</span> <span class="o">=</span> <span class="n">start_x</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">search1</span><span class="p">)</span> <span class="o">+</span> <span class="n">end_x</span> <span class="o">*</span> <span class="n">search1</span><span class="p">;</span>
<span class="n">current_position_y</span> <span class="o">=</span> <span class="n">start_y</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">search1</span><span class="p">)</span> <span class="o">+</span> <span class="n">end_y</span> <span class="o">*</span> <span class="n">search1</span><span class="p">;</span></code></pre></figure> <ul> <li>search1 is the linear interpolation factor.</li> <li>search0 is used to remember the last position on the line where the ray missed or didnt intersect with any geometry.</li> </ul> <figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">hit0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">hit1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></code></pre></figure> <ul> <li>hit0: there was an intersection during the first pass.</li> <li>hit1: there was an intersection during the second pass.</li> </ul> <figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">float</span> <span class="n">viewDistance</span> <span class="o">=</span> <span class="n">startView</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">thickness</span><span class="p">;</span></code></pre></figure> <ul> <li>viewDistance: how far away from the camera to the current fragment.</li> <li>depth: the view distance difference between the current ray point and scene position. It tells us how far behind or in front of the scene the ray currently is.</li> </ul> <figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="c1">//The first pass: to get a cursory point.
</span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="kt">int</span><span class="p">(</span><span class="n">delta</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">frag</span> <span class="o">+=</span> <span class="n">increment</span><span class="p">;</span>
    <span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">frag</span> <span class="o">/</span> <span class="n">texSize</span><span class="p">;</span> 
    <span class="n">positionTo</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">positionTexture</span><span class="p">,</span> <span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>

    <span class="n">search1</span> <span class="o">=</span>
      <span class="n">mix</span>
        <span class="p">(</span> <span class="p">(</span><span class="n">frag</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">startFrag</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="n">deltaY</span>
        <span class="p">,</span> <span class="p">(</span><span class="n">frag</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">startFrag</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">deltaX</span>
        <span class="p">,</span> <span class="n">useX</span>
        <span class="p">);</span>

    <span class="n">search1</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">search1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
    <span class="n">viewDistance</span> <span class="o">=</span> <span class="p">(</span><span class="n">startView</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">endView</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="n">mix</span><span class="p">(</span><span class="n">endView</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">startView</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">search1</span><span class="p">);</span>
    <span class="n">depth</span>        <span class="o">=</span> <span class="n">viewDistance</span> <span class="o">-</span> <span class="n">positionTo</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">depth</span> <span class="o">&lt;</span> <span class="n">thickness</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">hit0</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">search0</span> <span class="o">=</span> <span class="n">search1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure> <p>The first pass is the process of advancing the current fragment position closer to the end fragment. We will find a cursory hit point for the ray. The first pass contains four steps:</p> <ul> <li>Calculate the distance from the camera to current fragment. Sample from the viewPositionTexture: positionTo.y.</li> <li>Search1 is the percentage or portion of the line the current position represents.</li> <li>Using Search1, viewDistance can be interpolated for the current position.</li> <li>Depth is the distance between the fragment and the point on ray line.</li> <li>We can check whether the point hits geometry by Depth.</li> <li>The condition: depth &gt; 0 &amp;&amp; depth &lt; thickness means that, the distance between ray point and camera is little longer than the distance between fragment and camera.</li> <li>Be attention, the viewdistance is calculated by perspective-correct interpolation.</li> <li>Seach0 record the last iteration</li> </ul> <figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="c1">//The second pass
</span><span class="n">search1</span> <span class="o">=</span> <span class="n">search0</span> <span class="o">+</span> <span class="p">((</span><span class="n">search1</span> <span class="o">-</span> <span class="n">search0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">);</span>
<span class="n">steps</span> <span class="o">*=</span> <span class="n">hit0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">steps</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">frag</span> <span class="o">=</span> <span class="n">mix</span><span class="p">(</span><span class="n">startFrag</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">endFrag</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span> <span class="n">search1</span><span class="p">);</span>
    <span class="n">uv</span><span class="p">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">frag</span> <span class="o">/</span> <span class="n">texSize</span><span class="p">;</span>
    <span class="n">positionTo</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">positionTexture</span><span class="p">,</span> <span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>

    <span class="n">viewDistance</span> <span class="o">=</span> <span class="p">(</span><span class="n">startView</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">endView</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="n">mix</span><span class="p">(</span><span class="n">endView</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">startView</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">search1</span><span class="p">);</span>
    <span class="n">depth</span> <span class="o">=</span> <span class="n">viewDistance</span> <span class="o">-</span> <span class="n">positionTo</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">depth</span> <span class="o">&lt;</span> <span class="n">thickness</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">hit1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">search1</span> <span class="o">=</span> <span class="n">search0</span> <span class="o">+</span> <span class="p">((</span><span class="n">search1</span> <span class="o">-</span> <span class="n">search0</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="kt">float</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">search1</span><span class="p">;</span>
      <span class="n">search1</span> <span class="o">=</span> <span class="n">search1</span> <span class="o">+</span> <span class="p">((</span><span class="n">search1</span> <span class="o">-</span> <span class="n">search0</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
      <span class="n">search0</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure> <ul> <li>The second pass is a refine process to find the exactly point that the ray hit the geometry.</li> <li>Search1 is initialized as a value between the search0 and search1.</li> <li>The whole process is just like a dicotomizing search. In steps iterations, we can get a refinement for the hit point position.</li> </ul> <figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="c1">//final step: calculate the visible of the current hit point.
</span>  <span class="kt">float</span> <span class="n">visibility</span> <span class="o">=</span>
      <span class="n">hit1</span> <span class="c1">//step1
</span>    <span class="o">*</span> <span class="n">positionTo</span><span class="p">.</span><span class="n">w</span> <span class="c1">//step2
</span>    <span class="o">*</span> <span class="p">(</span> <span class="mi">1</span>
      <span class="o">-</span> <span class="n">max</span>
         <span class="p">(</span> <span class="n">dot</span><span class="p">(</span><span class="o">-</span><span class="n">unitPositionFrom</span><span class="p">,</span> <span class="n">pivot</span><span class="p">)</span>
         <span class="p">,</span> <span class="mi">0</span>
         <span class="p">)</span>
      <span class="p">)</span> <span class="c1">//step3
</span>    <span class="o">*</span> <span class="p">(</span> <span class="mi">1</span>
      <span class="o">-</span> <span class="n">clamp</span>
          <span class="p">(</span> <span class="n">depth</span> <span class="o">/</span> <span class="n">thickness</span>
          <span class="p">,</span> <span class="mi">0</span>
          <span class="p">,</span> <span class="mi">1</span>
          <span class="p">)</span>
      <span class="p">)</span><span class="c1">//step4
</span>    <span class="o">*</span> <span class="p">(</span> <span class="mi">1</span>
      <span class="o">-</span> <span class="n">clamp</span>
          <span class="p">(</span>   <span class="n">length</span><span class="p">(</span><span class="n">positionTo</span> <span class="o">-</span> <span class="n">positionFrom</span><span class="p">)</span>
            <span class="o">/</span> <span class="n">maxDistance</span>
          <span class="p">,</span> <span class="mi">0</span>
          <span class="p">,</span> <span class="mi">1</span>
          <span class="p">)</span>
      <span class="p">)</span><span class="c1">//step5
</span>    <span class="o">*</span> <span class="p">(</span><span class="n">uv</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">uv</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">)</span>
    <span class="o">*</span> <span class="p">(</span><span class="n">uv</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">uv</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">);</span><span class="c1">//step6
</span>
  <span class="n">visibility</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">visibility</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span></code></pre></figure> <p>The visible of the reflection point is affected by five factors:</p> <ul> <li>The visible is ranges from zero to one.</li> <li>step1: hit1 decide whether the ray hit geometry.</li> <li>step2: if w is zero, there is no scene position.</li> <li>step3: The reflection ray points torward the camera, and hit something. This situation is that, the ray hit some geometry’s backward.</li> <li>step4: We can find exact point where the reflection ray first intersects with the scene’s geometry. So we fade out the reflection the further it is from the intersection point.</li> <li>step5: Fade out the reflection based on how far way the reflected point is from the initial start point.</li> <li>step6: the point out of clip space.</li> </ul> <figure class="highlight"><pre><code class="language-cpp" data-lang="cpp">  <span class="n">uv</span><span class="p">.</span><span class="n">ba</span> <span class="o">=</span> <span class="n">vec2</span><span class="p">(</span><span class="n">visibility</span><span class="p">);</span>
  <span class="n">fragColor</span> <span class="o">=</span> <span class="n">uv</span><span class="p">;</span></code></pre></figure> <p>The final output color is like above.</p> <h3 id="specular-map">Specular Map</h3> <p>Specular Map show us which fragments need screen space reflection. Specular Map plays a role of mask texture in SSR. Just like gbuffer, we can get a specular map by deffered shadering.</p> <p>In my opinion, to make ssr support PBR material, we should calculate specular texture in PBR pipeline firstly. The specular texture can be used both in SSR merge stage and deffered lighting stage.</p> <h3 id="reflected-scene-colors">Reflected Scene Colors</h3> <p>Once we get the reflected uv texture, looking up the reflected colors is fairly easy.</p> <figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="c1">//get current fragment's uv
</span><span class="n">vec2</span> <span class="n">texSize</span>  <span class="o">=</span> <span class="n">textureSize</span><span class="p">(</span><span class="n">uvTexture</span><span class="p">,</span> <span class="mi">0</span><span class="p">).</span><span class="n">xy</span><span class="p">;</span>
<span class="n">vec2</span> <span class="n">texCoord</span> <span class="o">=</span> <span class="n">gl_FragCoord</span><span class="p">.</span><span class="n">xy</span> <span class="o">/</span> <span class="n">texSize</span><span class="p">;</span>

<span class="c1">//with reflected uv, we can get reflected color.
</span><span class="n">vec4</span> <span class="n">uv</span>    <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">uvTexture</span><span class="p">,</span>    <span class="n">texCoord</span><span class="p">);</span>
<span class="n">vec4</span> <span class="n">color</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">colorTexture</span><span class="p">,</span> <span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
  
<span class="c1">//sample the ssr visible
</span><span class="kt">float</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">uv</span><span class="p">.</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="c1">//get final color
</span><span class="n">fragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">mix</span><span class="p">(</span><span class="n">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">color</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span> <span class="n">alpha</span><span class="p">),</span> <span class="n">alpha</span><span class="p">);</span> </code></pre></figure> <h3 id="blurred-reflected-scene-colors">Blurred Reflected Scene Colors</h3> <p>Blur the reflected colors and store the blur texture in a framebuffer. The blurred reflected colors are used for surfaces that have a less than mirror.</p> <h3 id="final-ssr-color">Final SSR Color</h3> <p>The final SSR effect is influenced by reflected color and blur reflected color.</p> <figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="c1">//Input texture.
</span><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">colorTexture</span><span class="p">;</span> 
<span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">colorBlurTexture</span><span class="p">;</span>
<span class="c1">//Mask texture.
</span><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">specularTexture</span><span class="p">;</span>

<span class="c1">//Smaple
</span><span class="n">vec4</span> <span class="n">specular</span>  <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">specularTexture</span><span class="p">,</span>  <span class="n">texCoord</span><span class="p">);</span>
<span class="n">vec4</span> <span class="n">color</span>     <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">colorTexture</span><span class="p">,</span>     <span class="n">texCoord</span><span class="p">);</span>
<span class="n">vec4</span> <span class="n">colorBlur</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">colorBlurTexture</span><span class="p">,</span> <span class="n">texCoord</span><span class="p">);</span>

<span class="c1">//get specular amount
</span><span class="kt">float</span> <span class="n">specularAmount</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">specular</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span> <span class="n">vec3</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="mi">3</span><span class="p">;</span>

<span class="c1">//if specular is error. dot(specular.rgb, vec3(1)) == (specular.r + specular.g + specular.b);
</span><span class="k">if</span> <span class="p">(</span><span class="n">specularAmount</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">fragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="k">return</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">//get the roughness. In PBR, the step can be sample in roughness texture.
</span><span class="kt">float</span> <span class="n">roughness</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">min</span><span class="p">(</span><span class="n">specular</span><span class="p">.</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="c1">//final color 
</span>  <span class="n">fragColor</span> <span class="o">=</span> <span class="n">mix</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="n">colorBlur</span><span class="p">,</span> <span class="n">roughness</span><span class="p">)</span> <span class="o">*</span> <span class="n">specularAmount</span><span class="p">;</span></code></pre></figure> <p>Make a summary, the ssr is affected by these factors:</p> <ul> <li>roughness: control the final color between the color and colorblur.</li> <li>specular: calculated by specular vector.</li> </ul> <div class="entry-meta"> <br> <hr> <span class="entry-tags"><a href="https://onesilverbullet.github.io/silvergamer.github.io/tags/#Render" title="Pages tagged Render" class="tag"><span class="term">Render</span></a><a href="https://onesilverbullet.github.io/silvergamer.github.io/tags/#Screen Space" title="Pages tagged Screen Space" class="tag"><span class="term">Screen Space</span></a><a href="https://onesilverbullet.github.io/silvergamer.github.io/tags/#Graphics" title="Pages tagged Graphics" class="tag"><span class="term">Graphics</span></a><a href="https://onesilverbullet.github.io/silvergamer.github.io/tags/#Global Illumination" title="Pages tagged Global Illumination" class="tag"><span class="term">Global Illumination</span></a></span> <span class="social-share"> <a href="https://www.facebook.com/sharer/sharer.php?u=https://onesilverbullet.github.io/silvergamer.github.io/screen-space-reflection/" title="Share on Facebook" class="tag"> <span class="term"><i class="fa fa-facebook-square"></i> Share</span> </a> <a href="https://twitter.com/intent/tweet?text=https://onesilverbullet.github.io/silvergamer.github.io/screen-space-reflection/" title="Share on Twitter" class="tag"> <span class="term"><i class="fa fa-twitter-square"></i> Tweet</span> </a> <a href="https://plus.google.com/share?url=https://onesilverbullet.github.io/silvergamer.github.io/screen-space-reflection/" title="Share on Google+" class="tag"> <span class="term"><i class="fa fa-google-plus-square"></i> +1</span> </a> </span> <div style="clear:both"></div> </div> </div> </div> <section id="disqus_thread" class="animated fadeInUp"></section><!-- /#disqus_thread --> </header> <!-- JS --> <script src="https://onesilverbullet.github.io/silvergamer.github.io/assets/js/jquery-1.12.0.min.js"></script> <script src="https://onesilverbullet.github.io/silvergamer.github.io/assets/js/jquery.dlmenu.min.js"></script> <script src="https://onesilverbullet.github.io/silvergamer.github.io/assets/js/jquery.goup.min.js"></script> <script src="https://onesilverbullet.github.io/silvergamer.github.io/assets/js/jquery.magnific-popup.min.js"></script> <script src="https://onesilverbullet.github.io/silvergamer.github.io/assets/js/jquery.fitvid.min.js"></script> <script src="https://onesilverbullet.github.io/silvergamer.github.io/assets/js/scripts.js"></script> <script type="text/javascript"> var disqus_shortname = 'taylantatli'; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); (function () { var s = document.createElement('script'); s.async = true; s.type = 'text/javascript'; s.src = '//' + disqus_shortname + '.disqus.com/count.js'; (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s); }()); </script> <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> <!-- MathJax --> <script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> </body> </html>
